<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/electrum.ts</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/electrum.ts</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as electrum from 'rn-electrum-client/helpers';
import { err, ok, Result } from './result';

import {
	EAvailableNetworks,
	EElectrumNetworks,
	ElectrumConnectionPubSub,
	ElectrumConnectionSubscription,
	IFormattedPeerData,
	TProtocol
} from '../types';
import * as hardcodedPeers from 'rn-electrum-client/helpers/peers.json';

const POLLING_INTERVAL = 1000 * 20;
export const defaultElectrumPorts = ['51002', '50002', '51001', '50001'];

/**
 * Returns the default port for the given network and protocol.
 * @param {EAvailableNetworks} [selectedNetwork]
 * @param {string} [protocol]
 * @returns {number}
 */
export const getDefaultPort = (
	selectedNetwork: EAvailableNetworks,
	protocol: TProtocol
): number => {
	if (protocol === 'ssl') {
		return selectedNetwork === 'testnet' ? 51002 : 50002;
	} else {
		return selectedNetwork === 'testnet' ? 51001 : 50001;
	}
};

/**
 * Returns the protocol for the given network and default port.
 * @param {string} [port]
 * @param {EAvailableNetworks} [network]
 * @returns {TProtocol | undefined}
 */
export const getProtocolForPort = (
	port: string,
	network: EAvailableNetworks
): TProtocol | undefined => {
	if (port === '443') {
		return 'ssl';
	}

	if (network === 'testnet') {
		return port === '51002' ? 'ssl' : 'tcp';
	}

	return port === '50002' ? 'ssl' : 'tcp';
};

/**
 * Formats the peer data response from an Electrum server.
 * @param {[string, string, [string, string, string]]} data
 * @returns Result&lt;IFormattedPeerData>
 */
export const formatPeerData = (
	data: [string, string, [string, string, string]]
): Result&lt;IFormattedPeerData> => {
	try {
		if (!data) {
			return err('No data provided.');
		}
		if (data?.length !== 3) {
			return err('Invalid peer data');
		}
		if (data[2]?.length &lt; 2) {
			return err('Invalid peer data');
		}
		const [ip, host, ports] = data;
		const [version, ssl, tcp] = ports;
		return ok({
			ip,
			host,
			version,
			ssl,
			tcp
		});
	} catch (e) {
		if (typeof e === 'string' || e instanceof Error) {
			return err(e);
		}
		return err('Unable to format peer data.');
	}
};

/**
 * Returns an array of peers.
 * If unable to acquire peers from an Electrum server the method will default to the hardcoded peers in peers.json.
 * @param {EAvailableNetworks} [selectedNetwork]
 * @returns Promise&lt;Result&lt;IFormattedPeerData[]>>
 */
export const getPeers = async ({
	selectedNetwork
}: {
	selectedNetwork: EAvailableNetworks;
}): Promise&lt;Result&lt;IFormattedPeerData[]>> => {
	try {
		const response = await electrum.getPeers({ network: selectedNetwork });
		if (!response.error) {
			// Return an array of peers provided by the currently connected electrum server.
			const peers: IFormattedPeerData[] = [];
			await Promise.all(
				response.data.map(async (peer) => {
					const formattedPeer = await formatPeerData(peer);
					if (formattedPeer.isOk()) {
						peers.push(formattedPeer.value);
					}
				})
			);
			if (peers?.length > 0) {
				return ok(peers);
			}
		}
		// No peers available grab hardcoded peers instead.
		return ok(hardcodedPeers[selectedNetwork]);
	} catch (e) {
		if (typeof e === 'string' || e instanceof Error) {
			return err(e);
		}
		return err('Unable to get peers.');
	}
};

/**
 * Background task that checks the connection to the Electrum server with a PubSub
 * If connection was lost this will try to reconnect in the specified interval
 * @param {() => Result&lt;null>} [connectToElectrum]
 * @returns {ElectrumConnectionPubSub}
 */
export const electrumConnection = ((
	connectToElectrum?: () => Result&lt;null>
): ElectrumConnectionPubSub => {
	const subscribers: Set&lt;(isConnected: boolean) => void> = new Set();
	let latestState: boolean | null = null;

	setInterval(async () => {
		try {
			const { error } = await electrum.pingServer();

			if (error) {
				if (connectToElectrum) {
					console.log('Connection to Electrum Server lost, reconnecting...');
					const response = await connectToElectrum();

					if (response.isErr()) {
						electrumConnection.publish(false);
					}
				}
			} else {
				electrumConnection.publish(true);
			}
		} catch (e) {
			console.error(e);
		}
	}, POLLING_INTERVAL);

	const publish = (isConnected: boolean): void => {
		// Skip if no subscribers
		if (subscribers.size === 0) {
			return;
		}

		// Skip if state hasn't changed
		if (latestState === isConnected) {
			return;
		}

		latestState = isConnected;
		subscribers.forEach((callback) => callback(isConnected));
	};

	const subscribe = (
		callback: (isConnected: boolean) => void
	): ElectrumConnectionSubscription => {
		subscribers.add(callback);

		return {
			remove: (): void => {
				subscribers.delete(callback);
			}
		};
	};

	return { publish, subscribe };
})();

/**
 * Returns the network string for use with Electrum methods.
 * @param {EAvailableNetworks} [network]
 * @return {EElectrumNetworks}
 */
export const getElectrumNetwork = (
	network: EAvailableNetworks
): EElectrumNetworks => {
	switch (network) {
		case 'bitcoin':
			return EElectrumNetworks.bitcoin;
		case 'testnet':
			return EElectrumNetworks.bitcoinTestnet;
		case 'regtest':
			return EElectrumNetworks.bitcoinRegtest;
		default:
			return EElectrumNetworks.bitcoinTestnet;
	}
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Err.html">Err</a></li><li><a href="Ok.html">Ok</a></li></ul><h3>Global</h3><ul><li><a href="global.html#availableNetworks">availableNetworks</a></li><li><a href="global.html#btcToSats">btcToSats</a></li><li><a href="global.html#constructByteCountParam">constructByteCountParam</a></li><li><a href="global.html#decodeRawTransaction">decodeRawTransaction</a></li><li><a href="global.html#electrumConnection">electrumConnection</a></li><li><a href="global.html#err">err</a></li><li><a href="global.html#formatKeyDerivationPath">formatKeyDerivationPath</a></li><li><a href="global.html#formatPeerData">formatPeerData</a></li><li><a href="global.html#generateMnemonic">generateMnemonic</a></li><li><a href="global.html#getAddressFromKeyPair">getAddressFromKeyPair</a></li><li><a href="global.html#getAddressFromScriptPubKey">getAddressFromScriptPubKey</a></li><li><a href="global.html#getAddressIndexDiff">getAddressIndexDiff</a></li><li><a href="global.html#getAddressTypeFromPath">getAddressTypeFromPath</a></li><li><a href="global.html#getAddressesFromPrivateKey">getAddressesFromPrivateKey</a></li><li><a href="global.html#getDefaultPort">getDefaultPort</a></li><li><a href="global.html#getDefaultWalletData">getDefaultWalletData</a></li><li><a href="global.html#getDefaultWalletDataKeys">getDefaultWalletDataKeys</a></li><li><a href="global.html#getElectrumNetwork">getElectrumNetwork</a></li><li><a href="global.html#getHighestUsedIndexFromTxHashes">getHighestUsedIndexFromTxHashes</a></li><li><a href="global.html#getKeyDerivationPath">getKeyDerivationPath</a></li><li><a href="global.html#getKeyDerivationPathObject">getKeyDerivationPathObject</a></li><li><a href="global.html#getKeyDerivationPathString">getKeyDerivationPathString</a></li><li><a href="global.html#getKeyValue">getKeyValue</a></li><li><a href="global.html#getPeers">getPeers</a></li><li><a href="global.html#getProtocolForPort">getProtocolForPort</a></li><li><a href="global.html#getScriptHash">getScriptHash</a></li><li><a href="global.html#getSeed">getSeed</a></li><li><a href="global.html#getSeedHash">getSeedHash</a></li><li><a href="global.html#getSha256">getSha256</a></li><li><a href="global.html#getTapRootAddressFromPublicKey">getTapRootAddressFromPublicKey</a></li><li><a href="global.html#getTxFee">getTxFee</a></li><li><a href="global.html#isP2trPrefix">isP2trPrefix</a></li><li><a href="global.html#isValidBech32mEncodedString">isValidBech32mEncodedString</a></li><li><a href="global.html#objectKeys">objectKeys</a></li><li><a href="global.html#objectsMatch">objectsMatch</a></li><li><a href="global.html#ok">ok</a></li><li><a href="global.html#reduceValue">reduceValue</a></li><li><a href="global.html#removeDustOutputs">removeDustOutputs</a></li><li><a href="global.html#satsToBtc">satsToBtc</a></li><li><a href="global.html#setReplaceByFee">setReplaceByFee</a></li><li><a href="global.html#shuffleArray">shuffleArray</a></li><li><a href="global.html#validateAddress">validateAddress</a></li><li><a href="global.html#validateMnemonic">validateMnemonic</a></li><li><a href="global.html#validateTransaction">validateTransaction</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Tue Mar 26 2024 13:36:32 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
